###### 数据库的隔离级别

```tex
数据库支持的隔离级别
	读未提交->会发生脏读
	读已提交->会发生不可重复读
	可重复读->会发生幻读 
	串行化->解决所有问题

脏读->当数据库的隔离级别为读未提交的时候,可能会发生脏读。 脏读是指当会话A的数据未commit时,被会话B读取到。此时若是会话A由于某些原因将数据rollback时,会话B读取到的就是脏数据。解决方案就是设置数据库的隔离界别为读已提交。

不可重复读->简单的理解就是多次读取到的数据不一致。例如在会话A中多次读取的过程中,会话B修改某条数据并提交,导致会话A多次读取的数据不一致。解决方案就是设置数据库的隔离级别为可重复读。

幻读->可以理解为不可重复读的特殊场景。不可重复读是指在读取某条指定的记录时,前后多次读取到的数据不一致。而幻读是指在范围查找时,前后多次查找到的数据条数不一致。 解决方案就是设置数据库的隔离级别为串行化。
```



###### 事务四大特性

```tex
ACID:原子性 一致性 隔离性 持久性
```

###### 事务的传播类型

```tex
指的是事务与事务之间的交互策略。(例如在事务方法A中调用事务方法B,当事务方法B失败回滚时,事务方法A该如何操作,这就是事务传播类型)

针对事务的传播类型,我们要弄明白四个点
	1.子事务与父事务的关系,是否会开启一个新的事务。
	2.子事务异常时,父事务是否会回滚。
	3.父事务异常时,子事务是否会回滚。
	4.父事务捕获到异常时,父事务是否会回滚。

spring中定义了7种事务传播类型：
	REQUIRED: spring默认的事务传播类型,该传播类型的特点是->若是当前方法存在事务,子方法加入到该事务。此时父子方法公用一个事务,无论父子方法哪个发生异常,整个事务都会回滚。即使父方法捕获到了异常,也是会回滚。而当前方法如果不存在事务时,子方法新建一个事务。
	
	验证1:父方法不开启事务,子方法开启事务,当子方法遇到异常时,子方法回滚,父方法不会回滚。 ->(父方法不回滚,子方法回滚)
	验证2:父方法和字方法同时开启事务,当子方法异常时,父方法事务是否会回滚。->(父子方法都会回滚,因为在同一个事务中)
	验证3:父方法和子方法同时开启事务,当父方法异常时,子方法事务是否会回滚。->(父子方法都会回滚,因为在同一个事务中)
	验证4:当子方法的异常被父方法捕获时,事务是否会回滚。->(父子方法都会回滚)
	验证5:当父方法的异常被捕获时,事务是否会回滚。->(异常被捕获,不会回滚，这是错误的做法)
	
	REQUIRES_NEW：无论当前方法是否存在事务,子方法都会新建一个事务。此时父子方法的事务是独立的,父子方法的事务互不影响。但是父方法需要注意子方法抛出的异常,避免因为子方法的异常导致父方法回滚。
	
	验证1:子方法的异常,是否会影响父方法的回滚。(需要捕获子方法的异常) ->(不会影响)
	验证2:父方法的异常,是否会影响子方法的回滚。->(不会影响)
	
	NESTED：当前方法存在事务,子方法加在嵌套事务执行。当父方法事务回滚时,子方法事务也跟着回滚。当子方法事务发生回滚时,父方法是否回滚取决于是否捕获到了子方法的异常,如果捕获到的话,不会发生回滚。如果没有捕获,会发生回滚。(也就是父方法抛出异常或者子方法抛出异常,子方法都会发生回滚。而父方法只有在自身抛出异常或者未捕获到子方法抛出的异常时才会回滚。)
	
	验证1：父方法发生异常,判断子方法是否会回滚。->(父子方法都会回滚)
	验证2：子方法发生异常,父方法未捕获到异常,判断父方法是否会回滚。->(父子方法都会回滚)
	验证3：子方法发生异常,父方法捕获到异常,判断父方法是否会回滚。->(子方法回滚,父方法未回滚)
	
	
	SUPPORTS		
	MANDATORY
	NOT_SUPPORTED
	NEVER
```



###### spring事务的失效

```tex
由于spring事务的作用原理是AOP代理加@Transaction注解,所以一下情况可以导致事务失效。

1.没有@Transaction注解的方法内部调用@Transaction注解的方法。
2.直接方法调用,不通过对象调用也是会失效的。
3.没有被spring所管理的bean的方法。
4.被@Transaction注解修饰的方法必须是public方法。
5.底层使用的数据库必须支持事务。

6.spring事务执行过程中,抛出非RuntimeException 和非 Error 错误的其他异常，是不会回滚的。(必须修改@Transaction注解的拦截属性)
```

