并发编程 1.并发和并发的价值 2.了解线程 3.Java中线程的实现 4.多线程的基本原理 5.线程的启动和停止

并发
[高并发]当前系统能够同时承载的并发数 TPS:每秒处理的事务数量 QPS:每秒处理的查询数量

如何支撑高并发 硬件资源 CPU:(核心数,并行任务数量)
内存:
磁盘:
网卡:
软件 CPU->线程,8核,同时可以运行8个线程 IO->数据库交互->刷新到磁盘(内存 缓存 异步刷盘策略)   数据库分库分表 分布式缓存 分布式消息中间件 单节点遇到瓶颈,多个计算机组成一个分布式计算机 多线程技术 什么是线程

线程的生命周期 NEW->RUNNABLE->BLOCKED->WAITING->TIMED_WAITING->TERMINATED

停止线程 stop方法停止线程 interrupt()停止线程 唤醒处于阻塞状态下的线程 修改中断的标记,由false改为true

问题排查 排查问题(死锁问题)
jps 查看java进程 jstack PID(进程编号)

    排查问题(cpu占用很高的情况):
        top    命令查看当前资源占用情况
        top -c 查看进程和占用资源的排行榜
        top -H -p PID 定位到进程里面最消耗cpu的线程
        printf "0x%x\n" PID 将线程PID转换为16进制
        jstack 74232(进程PID) | grep -A 20 0x1224c(线程PID的16进制)

多线程常见情况 1.多个任务由多个线程来完成(不会出现线程安全问题)
2.单个任务由多个线程来完成(会出现线程安全问题)

分布式与高并发

1. 进程和线程的区别 进程是操作系统资源分配的最小单位。 线程是执行的最小单位。
2. 多线程 一个进程中，多个线程同时执行或交替执行。
3. 多线程产生的问题 原子性(synchronized AtomicXXX Lock) java的某个操作,在操作系统的底层可能会分成多个指令来完成,这些指令执行之间,会插入其它线程执行的指令。 可见性(synchronized
   volatile)       java的内存模型,主内存和工作内存。在工作内存中修改了某个值,不能够及时刷新到主内存中去。 有序性(synchronized volatile)       指令重排导致的问题。

    可见性(volatile)(深度优化 活性失败 伪共享问题)
        线程可见性问题:线程A对于一个共享变量的修改,对线程B不可见。
        可见性问题的本质:
            cpu资源的利用问题
                cpu增加高速缓存
                指令重排序
                操作系统增加进程 线程 -> 通过cpu的时间片切换,提升cpu利用率
                编译器(JVM深度优化)

    cpu层面的指令重排序
                
    有序性

4. cas：底层是lock cas。
5. synchronize关键字解析 使用:静态方法(类对象为锁)  普通方法(this对象为锁)  代码块(显示指定锁)
   影响锁的作用范围,本质上就是对象的生命周期 抢占锁的本质是互斥,如何实现互斥-共享资源 分析:队列存储(同步队列)

jdk1.6之前:无锁->重量级锁 jdk1.6之后:
无锁 偏向锁 轻量级锁 重量级锁

重量级锁:
用户态到内核态的交换 没有获得锁的线程会阻塞,获得锁之后在被唤醒

6. 线程通信 wait和notify方法(线程同步 等待队列)

cpu跟内存的交互 cpu的高速缓存 L1 L2 cpu独占 L3 cpu共享 三级缓存如何工作L1d(数据缓存)   L1i(指令缓存)    