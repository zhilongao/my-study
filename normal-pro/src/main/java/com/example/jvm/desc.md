1. 原码文件编译过程
原码 -编译(词法分析器->tokens流->语法分析器->语法树/抽象语法树->语义分析器->注解抽象语法树->字节码生成器)-> 类文件

2. 类文件到虚拟机(类文件加载)
    装载(查找和导入class文件):
        通过一个类的全限定名获取定义此类的二进制字节流。
        将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
        在java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些对象的访问入口。
    链接 
        验证：保证被加载类的正确性。
        准备：为类的静态变量分配内存，并将其初始化为默认值。
        解析：把类中的符号引用转化为直接引用。
    初始化
        对类的静态变量，静态代码块执行初始化操作。
        
3. 类的装载(类加载器)
    Bootstrap ClassLoader(启动类加载器)
    Extension ClassLoader(扩展类加载器)
    com.util.App ClassLoader(应用类加载器)
    
    类加载的机制： 双亲委派机制。
    
4. 运行时数据区
    方法区(Method Area)：
        各个线程共享的内存区域，虚拟机启动时创建。
        用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。
        虽然java虚拟机规范把方法区描述为推的一个逻辑部分，但是它有一个别名叫做Non-Heap(非堆)，目的是与java堆区分开来。
        当方法区无法满足内存分配需求时，将抛出OutOfMemoryError错误。
        方法区在jdk8中为Metaspace,在jdk 6或7中是Perm Space  
        Run-Time Control Pool(运行时常量池，存放字面量 符号引用)
    堆(Heap)
        各个线程共享的内存区域，虚拟机启动时创建。(java对象以及数组都是在堆上分配)
    虚拟机栈(Java Virtual Machine Stacks)
        线程私有，随着线程的创建而创建。
        一个线程的执行区域，保存着一个线程中方法的调用状态。
        栈中以栈帧为单位，栈帧中存储者：局部变量表，操作数栈，动态链接(指向运行时常量池的引用)，方法返回地址和附加信息。
            局部变量表：方法内部定义的变量，方法参数。
            操作数栈：以出栈和压栈的方式存储操作数的。
            动态链接: 每个栈帧中都包含一个指向运行时常量池中该栈帧所属方法的引用。
    程序计数器(The pc Register)
        记录一个线程的执行区域。
    本地方法栈(Native Method Stacks) 
    
    
5. 虚拟机栈的内部结构

6. java对象的内存布局(对象头 实例数据 对其填充)    

7. 内存模型
    一块是堆区，一块是非堆区，堆区分为两块，一块是young区，一块是old区。
    
8. 垃圾回收
    如何确定一个对象是垃圾
        引用分析：弊端是存在相互引用的对象不能够被回收掉。
        可达性分析：需要确定GC ROOT，可作为GC ROOT的对象(类加载器 Thread 虚拟机栈的本地变量表 static成员 常量引用 本地方法栈的变量等)
    如何回收垃圾(垃圾回收算法)
        标记清除算法(Mark-Sweep)
            特点：标记 清除
            缺点：空间碎片 耗时
        复制回收算法(Copying)
            特点：两块空间 复制存活对象到另一半
            缺点：空间利用率低
        标记整理算法(Mark-Compact)
            特点：标记 移动 清除
            缺点：耗时
    运行时数据区采用的垃圾收集算法，分代采用不同的算法
        新生代：复制算法(Copying)。原因是young区存活的对象较少。
        老年代：标记清除或标记整理。原因是old区存活大多数对象，没必要复制。
        
    垃圾回收算法的落地-垃圾收集器
        Serial收集器
            特点：
                最基本，历史最悠久的垃圾收集器，jdk1.3之前新生代的唯一选择。
                复制算法 单线程 stop-the-world
            使用场景：Client模式下新生代的默认垃圾收集器。
        ParNew收集器
            特点：
                复制算法 多线程 stop-the-world
            使用场景：Server模式下新生代的默认垃圾收集器。
        Parallel Scavenge收集器(并行清理)
            特点：
                复制算法 关注系统吞吐量
                吞吐量=运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)
                控制参数：
                    -XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间
                    -XX:GCTimeRation 直接设置吞吐量的大小
            使用场景：     
        Serial Old收集器
            特点：
                标记整理算法 Serial的老年代版本
            使用场景：   
        Parallel Old收集器
            特点：
                标记整理算法 关注系统吞吐量
            使用场景：
        CMS收集器(Concurrent Mark Sweep)
            特点：
                标记清除算法 追求最短回收停顿时间 
            过程：
                初始标记(CMS initial mark)
                并发标记(CMS concurrent mark)
                重新标记(CMS remark)
                并发清除(CMS concurrent sweep)
            使用场景：   
                并发收集 低停顿
                大量空间碎片 并发阶段会降低吞吐量
        G1收集器